# 模块

平台上的脚本中可以引用全局模块, 或通过 require 引用定义模块.


## 导入

脚本可以导入另一个脚本定义的函数, 被导入的脚本叫模块, 可能来自三个地方:

1. 系统定义模块, 直接导入模块名称即可返回.
2. nodejs 模块, 这些模块使用原生 js 写成, 存储于 xboson-node-modules 目录中, 并可以根据需要使用 npm 安装, nodejs 模块要求不能依赖 native, 不能使用高于 es5 的语法.
3. 另一个服务脚本, 一旦这么做, 这个脚本就不可以通过 http 请求来访问, 只能被 require() 导入使用.

> 一个已经 '发布' 的脚本引用一个 '开发中' 且未 '发布' 过的脚本会返回 null,   
> 从而可能抛出 `TypeError: Cannot call undefined` 异常.   
> 因为开发环境和生产环境是独立的脚本上下文.


```javascript
//
// 导入系统模块
//
var fs = require('fs');
//
// 导入 nodejs 模块
//
var lodash = require('lodash');
//
// 导入平台脚本
// 只能导入同一个应用下的模块/接口.
//
var lib = require("./lib");
```


## 导出

这里只对平台脚本导出来做说明.

在脚本环境中, 向 module.exports 上导出的对象, 可以通过 require 来导入.

```javascript
module.exports = {
  //
  // 导出属性
  //
  name : 'lib',
  //
  // 导出函数
  //
  open : function() {},
}
```

> 注意: 因为多个接口脚本可以引用同一个模块, 这相当于多线程访问, 
> 此时模块导出函数不应引用(可以读取但不要写入) 超过当前函数范围的变量,
> 如多个接口脚本同时写入/读取模块内的顶级变量, 这会导致死锁或异常.


# 函数定义说明: 

可选参数被 [] 符号包围, 这种写法是为说明函数定义, 不要再代码中出现; 
参数名称用于做说明引用, 代码中的形参可以任意起名;

> 模块名.函数名(参数类型:参数名称, 可选的参数[, 参数类型:参数名称])  
