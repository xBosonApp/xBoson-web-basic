# 分布式锁

锁将在集群的多个节点上应用.

在一个接口脚本中嵌套的打开多个锁会导致死锁.

```js
var lc = require('lock')
var some = lc.open('lock-name');
some.lock();
some.unlock();
```


# API

`var lc = require('lock')`


## Lock open(String name)

打开一个命名分布式锁, 返回锁的实例.

## Lock api()

在脚本层面创建分布式锁, 返回锁的实例.
不同机构相同的应用将获取不同的锁对象.

## Lock mod()

在应用的模块层面创建分布式锁, 返回锁的实例.
不同机构相同的应用将获取不同的锁对象.

## Lock app()

在应用层面创建分布式锁, 返回锁的实例;
不同机构相同的应用将获取不同的锁对象.

谨慎使用, 很少脚本需要在应用层面锁定业务.

## Lock org()

在机构层面创建分布式锁, 返回锁的实例.

谨慎使用, 很少脚本需要在机构层面锁定业务.

## Lock node()

在集群节点上创建分布式锁, 返回锁的实例.

谨慎使用, 很少脚本需要在节点层面锁定业务.


# Class Lock

锁的实例, 锁不可以重入, 重入将抛出异常.
在一个业务脚本中嵌套的打开多个锁将导致死锁, 并且其他打开该锁的脚本也将被牵连.
如果接口创建的锁没有明确在脚本结束后释放(unlock) 平台将自动释放这些锁.

## lock()

获得锁。
如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。

## lockInterruptibly()

## tryLock()

如果可用，则获取锁，并立即返回值为true 。 如果锁不可用，则此方法将立即返回值为false 。

## tryLock(int millisecond)

如果锁可用，此方法将立即返回值为true 。 如果锁不可用，则当前线程将被禁用以进行线程调度，并且处于休眠状态，直至发生三件事情之一：

* 当前线程获取了锁
* 指定的等待时间过去了

## unlock()

释放锁。

只有锁的持有者可以释放它，并且如果限制被违反则会引发异常。